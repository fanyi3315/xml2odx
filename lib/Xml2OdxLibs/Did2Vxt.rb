# Converts internal DID representation to VXT xml file
#
# Copyright (C) 2014 Kresimir Spisic <keko@spisic.de>
# See COPYING for the License of this software

require 'nokogiri'

@Delta = 10

def getUniqueVarName(param)
	return "VAR_" + param.shortname + param.dop
end

def generateTestModule(did_array, other_xml_test_module, testgroup_name, ecu_name)

	often_used_code = nil

	builder = Nokogiri::XML::Builder.new do |xml|
	  xml.testmodule(	'xmlns:xsi' => 'http://www.w3.org/2001/XMLSchema-instance',
						#'xmlns'     => 'http://www.vector-informatik.de/CANoe/TestModule/1.15',
						'xsi:schemaLocation' => 'http://www.vector-informatik.de/CANoe/TestModule/1.15 testmodule.xsd',
						:title 		=> "Toyota Tests",
						:version	=> "1.0") {
		xml.description 'Autogenerated Test to test Toyota DID Read and Write Diag Services'
		xml.preparation {
			did_array.each { |did|
				did.params.each { |param| 
					xml.vardef('0', :name => getUniqueVarName(param), :type => "int")
				}
			}
		}
		xml.testgroup(:title => "Read and Write Parameters [#{testgroup_name}]") {
			did_array.each { |did|
				xml.testcase(:ident => "#{did.name}_Read", :title => "0x#{did.id.to_i.to_s(16).upcase}: #{did.name}: Read all Parameters of DID, write Parameters with Delta and read back") {
					xml.diagservice(:title => "#{did.name}_Read", :result => "pos", :ecu => ecu_name, :service => "#{did.name}_Read") {
						xml.diagrequest
						xml.diagresponse {
							did.params.each { |param|
								if not param.isArray then
									xml.diagparam(:qualifier => param.shortname, :copytovar => getUniqueVarName(param))	{
										xml.var(:name => getUniqueVarName(param))
									}
								else
									puts "array: " + param.inspect
								
								end
							}
						}
					}
					did.params.each { |param|
						if not param.isArray then
							xml.varset_bycapl(:name => getUniqueVarName(param)) {
								xml.caplfunction { 
									max = 2**param.lengthinbits - 1
									var = getUniqueVarName(param)
									xml.cdata("if(#{max} - delta >= #{var}) #{var} = #{var} + delta; else if(#{var} >= delta) #{var} = #{var} - delta; else #{var} = 0;")
								}
								xml.caplparam("#{@Delta}", :name => "delta", :type => "int")
							}
						end
					}
					if did.rw.include? "Write" then
						xml.diagservice(:title => "#{did.name}_Write", :result => "pos", :ecu => ecu_name, :service => "#{did.name}_Write") {
							xml.diagrequest {
								did.params.each { |param|
									if not param.isArray then
										xml.diagparam(:qualifier => param.shortname)	{
											xml.var(:name => getUniqueVarName(param))
										}
									end
								}
							}
							xml.diagresponse
						}
						often_used_code = Proc.new { |did|
							xml.diagservice(:title => "#{did.name}_Read", :result => "pos", :ecu => ecu_name, :service => "#{did.name}_Read") {
								xml.diagrequest
								xml.diagresponse {
									did.params.each { |param|
										if not param.isArray then
											xml.diagparam(:qualifier => param.shortname)	{
												xml.var(:name => getUniqueVarName(param))
											}
										end
									}
								}
							}
						}
						often_used_code.call(did)
					end
				}
			}
		}
		
		xml.testgroup(:title => "Read back Parameters after ECU Reset [#{testgroup_name}]") {
			xml.testcase(:ident => "Manual Reset", :title => "Manual Reset") {
				xml.testerconfirmation("Please reset ECU manually and press button", :title => "Wait for user interaction")
			}
			
			did_array.each { |did|
				xml.testcase(:ident => "#{did.name}_Read", :title => "0x#{did.id.to_i.to_s(16).upcase}: #{did.name}: Read all Parameters of DID after ECU Reset") {
					if did.rw.include? "Write" then
						often_used_code.call(did)
					end
				}
			}
		}
	  }
	end

	#merge with other xml input file
	if other_xml_test_module != nil then
		preparation_node = other_xml_test_module.at("preparation")
		testgroup_node = other_xml_test_module.at("testgroup")
		
		preparation_node.add_child(builder.doc.at('preparation').children)
		testgroup_node.add_next_sibling(builder.doc.xpath('//testgroup'))
	else
		other_xml_test_module = builder.doc
	end
	
	return other_xml_test_module
end